""" LUT preset
    A preset is a dict containing LUT parameters.
    The dict must have these attributes:
    {
    'type': <'default' or '1D' or '2D' or '3D'>,
    'extension': <str value>,
    'input_range': <[int/float, int/float]>,
    'output_range': <[int/float, int/float]>,
    'output_bitdepth': <int value>,
    'cube_size': <int value>,
    'title': <str value>,
    'comment': <str value>,
    'version': <str value>
    }
    See attribute constant below.

    When 1D or 2D type is chosen, preset must define output_bitdepth but
    shouldn't define cube_size.

    When 3D is chosen, preset must define cube_size but shouldn't define
    output_bitdepth.

    'default' is used to declare default sets, it must define both
    output_bitdepth and cube_size

.. moduleauthor:: `Marie FETIVEAU <github.com/mfe>`_

"""
__version__ = "0.3"
import collections
from utils.color_log_helper import print_warning_message
import json
import os
import ntpath


class PresetException(Exception):
    """Module custom exception

    """
    pass

# Attributes
TYPE = 'type'
TYPE_CHOICE = ['default', '1D', '2D', '3D']
EXPORT_CHOICE = ['1D', '2D', '3D']
EXT = 'extension'
VERSION = 'version'
TITLE = 'title'
COMMENT = 'comment'
IN_RANGE = 'input_range'
OUT_RANGE = 'output_range'

# 1D / 2D specific attribute
OUT_BITDEPTH = 'output_bitdepth'

# Smooth Specify how many points are computed.
# A first subsampled curve is first processed and then resample with
# a smooth to fit input lutsize.
# So the smaller this value is, the smoother the curve will be.
# 1D / 2D only
# Ex: 10, 20,...
SMOOTH = 'smooth'

# 3D specific attribute
CUBE_SIZE = 'cube_size'

# ascii specific attributes
WRITE_INDEX = 'write_index'
WRITE_ALPHA = 'write_alpha'
IS_FLOAT = 'is_float'
# layout option
LAYOUT = 'layout'
# with block layout, channel values are written by block. Ex: first red values,
# then green values...
BLOCK_LAYOUT = 'block'
# with line layout, values are written triplet by triplet
TRIPLET_LAYOUT = 'triplet'
SEPARATOR = 'separator'
# header types
HEADER_TYPE = 'header_type'
LUSTRE_HEADER = 'lustre_header'
SCRATCH_HEADER = 'scratch_header'


BASIC_ATTRS = [TYPE, EXT, VERSION, TITLE, COMMENT, IN_RANGE, OUT_RANGE]

BITDEPTH_MAX_VALUE = 128
BITDEPTH_MIN_VALUE = 8
CUBE_SIZE_MAX_VALUE = 128
CUBE_SIZE_MIN_VALUE = 3

FLOAT_BOUNDARY = 100.0

RAISE_MODE = 'raise'
FILL_MODE = 'fill'

MISSING_ATTR_MESSAGE = "Preset must have '{0}' attribute"

# Presets on disk

PRESET_DEFAULT_DIR = 'presets'
PRESET_ENV = 'LUT_PRESETS'


def get_default_preset():
    """ Get a general default preset.
        Values were chosen considering common LUT use cases.

    """
    return {
        TYPE: "default",
        EXT: ".lut",
        IN_RANGE: [0.0, 1.0],
        OUT_RANGE: [0.0, 1.0],
        OUT_BITDEPTH: 12,
        CUBE_SIZE: 17,
        TITLE: "LUT",
        COMMENT: ("Generated by ColorPipe-tools"
                  ).format(__version__),
        VERSION: "1"
        }


def is_range(arange):
    """ Return True if range is a collection composed of 2 int or float

    """
    if not isinstance(arange, collections.Iterable):
        return False
    if len(arange) != 2:
        return False
    for value in arange:
        if not isinstance(value, (int, float)):
            return False
    return True


def is_3d_preset(preset):
    """ Check if preset is valid for 3D LUTs
        Should be used after a check or complete

    """
    if preset[TYPE] == 'default' or preset[TYPE] == '3D':
        return True
    return False


def is_1d_or_2d_preset(preset):
    """ Check if preset is valid for 1D / 2D LUTs
        Should be used after a check or complete

    """
    if (preset[TYPE] == 'default'
            or preset[TYPE] == '1D'
            or preset[TYPE] == '2D'):
        return True
    return False


def is_int(arange):
    """ Check if a range is int

    Args:
        test_range ([int/float, int/float]): range to test

    Returns:
        .boolean

    """
    if (isinstance(arange[0], int)
            and isinstance(arange[1], int)):
        return True
    return False


def _get_range_float_message(arange):
    """ Get range warning/error message

    Returns:
        .str

    """
    return ("Range is expected to be float."
            " Ex: [0.0, 1.0] or [-0.25, 2.0].\nYour range {0}"
            ).format(arange)


def _get_range_int_message(arange):
    """ Get range warning/error message

    Returns:
        .str

    """
    return ("Range is expected to be int."
            " Ex: [0, 1023] or [0, 65535].\nYour range {1}"
            ).format(arange)


def check_range_is_float(arange, message=None):
    """ Check output range. Some LUT are float.
        Print a warning or raise an error

    """
    if message is None:
        message = _get_range_float_message(arange)
    if is_int(arange):
        raise PresetException(message)
    elif arange[1] > FLOAT_BOUNDARY:
        message = ("{0} seems too big !\n"
                   "Please check this, if the LUT isn't what you expected"
                   ).format(message)
        print_warning_message(message)


def check_range_is_int(arange, message=None):
    """ Check input / output range. Some LUT are int.
        Print a warning or raise an error

    """
    if message is None:
        message = _get_range_int_message(arange)
    if not is_int(arange):
        raise PresetException(message)
    elif arange[1] < BITDEPTH_MAX_VALUE:
        message = ("{0} seems too low !\n"
                   "Please check this, if the LUT isn't what you expected"
                   ).format(message)
        print_warning_message(message)


def convert_string_to_number(string):
    """ Convert a string number into a float or an int

    """
    try:
        return int(string)
    except ValueError:
        return float(string)


def convert_string_range(arange):
    """ Convert a string number range into a float or an int

    """
    return [convert_string_to_number(value) for value in arange]


def string_preset(preset):
    """ Print preset

    """
    string = '{\n'
    for attr in list(preset.keys()):
        string = "{0}  {1}: {2},\n".format(string, attr, preset[attr])
    string += '}\n'
    return string


# Read and write preset on disk

def write_preset(file_path, preset):
    """Write a preset as a json file

    """
    presetfile = open(file_path, 'w+')
    json.dump(preset, presetfile)
    presetfile.close()


def read_preset(file_path):
    """Read a preset from a json file

    """
    preset_data = open(file_path, 'r').read()
    return json.loads(preset_data)


# Get presets present in the environment


def get_default_preset_path():
    """ Return default preset path

    Returns:
        .str

    """
    return os.path.join(os.path.dirname(os.path.realpath(__file__)),
                        PRESET_DEFAULT_DIR)


def get_env_items():
    """ Return preset paths contained in preset environment variable

    Returns:
        .str

    """
    items = os.getenv(PRESET_ENV, get_default_preset_path())
    if items:
        return items
    return get_default_preset_path()


def _check_and_load_preset(file_path, presets):
    """ Check if the file is a json file and try to load a preset dict.
    On success, resulting preset is added to presets.
    On failure, presets remains untouched

    Returns:
        .dict {str, preset}

    """
    if not file_path.lower().endswith(".json"):
        return presets
    try:
        preset = read_preset(file_path)
    except ValueError:
        return presets
    if preset is None or not isinstance(preset, dict):
        return presets
    file_name = os.path.splitext(ntpath.basename(file_path))[0]
    presets[file_name] = preset
    return presets


def get_presets_from_env():
    """ Return a dict containing presets found in environment.

    Returns:
        .dict {str, preset}

    """
    items = get_env_items().split(os.pathsep)
    presets = {}
    for item in items:
        if os.path.isfile(item):
            presets = _check_and_load_preset(item, presets)
        elif os.path.isdir(item):
            for file_name in os.listdir(item):
                file_path = os.path.join(item, file_name)
                if os.path.isfile(file_path):
                    presets = _check_and_load_preset(file_path, presets)
    return presets
